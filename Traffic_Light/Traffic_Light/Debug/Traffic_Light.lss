
Traffic_Light.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009a4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000a18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000a  00800060  00800060  00000a18  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000a18  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000a48  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000180  00000000  00000000  00000a84  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001138  00000000  00000000  00000c04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008a6  00000000  00000000  00001d3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c42  00000000  00000000  000025e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002b8  00000000  00000000  00003224  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000057c  00000000  00000000  000034dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000988  00000000  00000000  00003a58  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000110  00000000  00000000  000043e0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
   4:	0c 94 94 01 	jmp	0x328	; 0x328 <__vector_1>
   8:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
   c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  10:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  14:	0c 94 f5 01 	jmp	0x3ea	; 0x3ea <__vector_5>
  18:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  1c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  20:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  24:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  28:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  2c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  30:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  34:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  38:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  3c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  40:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  44:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  48:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  4c:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  50:	0c 94 4c 00 	jmp	0x98	; 0x98 <__bad_interrupt>
  54:	57 03       	mulsu	r21, r23
  56:	5a 03       	fmul	r21, r18
  58:	5e 03       	fmul	r21, r22
  5a:	62 03       	mulsu	r22, r18
  5c:	66 03       	mulsu	r22, r22
  5e:	6a 03       	fmul	r22, r18
  60:	6e 03       	fmul	r22, r22
  62:	72 03       	mulsu	r23, r18
  64:	c2 03       	fmuls	r20, r18
  66:	c5 03       	fmuls	r20, r21
  68:	c9 03       	fmulsu	r20, r17
  6a:	cd 03       	fmulsu	r20, r21
  6c:	d1 03       	fmuls	r21, r17
  6e:	d5 03       	fmuls	r21, r21
  70:	d9 03       	fmulsu	r21, r17
  72:	dd 03       	fmulsu	r21, r21

00000074 <__ctors_end>:
  74:	11 24       	eor	r1, r1
  76:	1f be       	out	0x3f, r1	; 63
  78:	cf e5       	ldi	r28, 0x5F	; 95
  7a:	d8 e0       	ldi	r29, 0x08	; 8
  7c:	de bf       	out	0x3e, r29	; 62
  7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_clear_bss>:
  80:	20 e0       	ldi	r18, 0x00	; 0
  82:	a0 e6       	ldi	r26, 0x60	; 96
  84:	b0 e0       	ldi	r27, 0x00	; 0
  86:	01 c0       	rjmp	.+2      	; 0x8a <.do_clear_bss_start>

00000088 <.do_clear_bss_loop>:
  88:	1d 92       	st	X+, r1

0000008a <.do_clear_bss_start>:
  8a:	aa 36       	cpi	r26, 0x6A	; 106
  8c:	b2 07       	cpc	r27, r18
  8e:	e1 f7       	brne	.-8      	; 0x88 <.do_clear_bss_loop>
  90:	0e 94 1f 02 	call	0x43e	; 0x43e <main>
  94:	0c 94 d0 04 	jmp	0x9a0	; 0x9a0 <_exit>

00000098 <__bad_interrupt>:
  98:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000009c <app_start>:
{
	uint32_t five_seconds = 5;
	
	// initiate all pins used in this program
	
	Led_init(port_A , 0);  // set direction of pin 0 in portA output (car_green)
  9c:	60 e0       	ldi	r22, 0x00	; 0
  9e:	81 e4       	ldi	r24, 0x41	; 65
  a0:	0e 94 0c 02 	call	0x418	; 0x418 <Led_init>
	Led_init(port_A , 1);  // set direction of pin 1 in portA output (car_yellow)
  a4:	61 e0       	ldi	r22, 0x01	; 1
  a6:	81 e4       	ldi	r24, 0x41	; 65
  a8:	0e 94 0c 02 	call	0x418	; 0x418 <Led_init>
	Led_init(port_A , 2);  // set direction of pin 2 in portA output (car_red)
  ac:	62 e0       	ldi	r22, 0x02	; 2
  ae:	81 e4       	ldi	r24, 0x41	; 65
  b0:	0e 94 0c 02 	call	0x418	; 0x418 <Led_init>
	Led_init(port_B , 0);  // set direction of pin 0 in portB output (pedestrain_green)
  b4:	60 e0       	ldi	r22, 0x00	; 0
  b6:	82 e4       	ldi	r24, 0x42	; 66
  b8:	0e 94 0c 02 	call	0x418	; 0x418 <Led_init>
	Led_init(port_B , 1);  // set direction of pin 1 in portB output (pedestrain_yellow)
  bc:	61 e0       	ldi	r22, 0x01	; 1
  be:	82 e4       	ldi	r24, 0x42	; 66
  c0:	0e 94 0c 02 	call	0x418	; 0x418 <Led_init>
	Led_init(port_B , 2);  // set direction of pin 2 in portB output (pedestrain_red)
  c4:	62 e0       	ldi	r22, 0x02	; 2
  c6:	82 e4       	ldi	r24, 0x42	; 66
  c8:	0e 94 0c 02 	call	0x418	; 0x418 <Led_init>
	
// -------------------------------------------------------------------------------------
	Button_Init(port_D , 2); // set direction of pin2 in portD (push button) to be input
  cc:	62 e0       	ldi	r22, 0x02	; 2
  ce:	84 e4       	ldi	r24, 0x44	; 68
  d0:	0e 94 1b 02 	call	0x436	; 0x436 <Button_Init>
// -------------------------------------------------------------------------------------	
    Timer0_Mode(Normal);     // set mode of the timer to normal mode
  d4:	80 e0       	ldi	r24, 0x00	; 0
  d6:	0e 94 37 03 	call	0x66e	; 0x66e <Timer0_Mode>
// -------------------------------------------------------------------------------------
    Timer2_Mode(Normal);
  da:	80 e0       	ldi	r24, 0x00	; 0
  dc:	0e 94 a2 03 	call	0x744	; 0x744 <Timer2_Mode>
// -------------------------------------------------------------------------------------
    Interrupt0_Init();                    // Initiate Interrupt 0
  e0:	0e 94 29 03 	call	0x652	; 0x652 <Interrupt0_Init>
	Timer2_InT();                        // overflow interrupts in timer 2
  e4:	0e 94 33 03 	call	0x666	; 0x666 <Timer2_InT>
// -------------------------------------------------------------------------------------

	while(1){
		
		switch (state)
  e8:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <state>
  ec:	81 30       	cpi	r24, 0x01	; 1
  ee:	09 f4       	brne	.+2      	; 0xf2 <app_start+0x56>
  f0:	87 c0       	rjmp	.+270    	; 0x200 <app_start+0x164>
  f2:	68 f1       	brcs	.+90     	; 0x14e <app_start+0xb2>
  f4:	82 30       	cpi	r24, 0x02	; 2
  f6:	09 f4       	brne	.+2      	; 0xfa <app_start+0x5e>
  f8:	a8 c0       	rjmp	.+336    	; 0x24a <app_start+0x1ae>
  fa:	83 30       	cpi	r24, 0x03	; 3
  fc:	09 f4       	brne	.+2      	; 0x100 <app_start+0x64>
  fe:	f0 c0       	rjmp	.+480    	; 0x2e0 <app_start+0x244>
 100:	f3 cf       	rjmp	.-26     	; 0xe8 <app_start+0x4c>
		
		//------------------------------------------------------------
		
		case 0 :                                   // first case when cars is green and pedestrian is red
		while( counting < five_seconds ){          // increment 10 times of .5 to reach 5 seconds
			if (state == 1)                        // check if there is interrupt or not 
 102:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <state>
 106:	81 30       	cpi	r24, 0x01	; 1
 108:	91 f1       	breq	.+100    	; 0x16e <app_start+0xd2>
			{ 
				counting = 0;                      // if there is interrupt reset counting and break
				break;
			}
			else if (state == 0)                   // if there is no interrupt it will go back to normal function 
 10a:	81 11       	cpse	r24, r1
 10c:	20 c0       	rjmp	.+64     	; 0x14e <app_start+0xb2>
			{
		Led_on(port_A , 0);
 10e:	60 e0       	ldi	r22, 0x00	; 0
 110:	81 e4       	ldi	r24, 0x41	; 65
 112:	0e 94 10 02 	call	0x420	; 0x420 <Led_on>
		Led_on(port_B , 2);
 116:	62 e0       	ldi	r22, 0x02	; 2
 118:	82 e4       	ldi	r24, 0x42	; 66
 11a:	0e 94 10 02 	call	0x420	; 0x420 <Led_on>
        Timer0_Delay_half_second();                // delay .5 second
 11e:	0e 94 9b 03 	call	0x736	; 0x736 <Timer0_Delay_half_second>
		counting = counting + .5;
 122:	60 91 62 00 	lds	r22, 0x0062	; 0x800062 <counting>
 126:	70 91 63 00 	lds	r23, 0x0063	; 0x800063 <counting+0x1>
 12a:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <counting+0x2>
 12e:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <counting+0x3>
 132:	20 e0       	ldi	r18, 0x00	; 0
 134:	30 e0       	ldi	r19, 0x00	; 0
 136:	40 e0       	ldi	r20, 0x00	; 0
 138:	5f e3       	ldi	r21, 0x3F	; 63
 13a:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <__addsf3>
 13e:	60 93 62 00 	sts	0x0062, r22	; 0x800062 <counting>
 142:	70 93 63 00 	sts	0x0063, r23	; 0x800063 <counting+0x1>
 146:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <counting+0x2>
 14a:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <counting+0x3>
		{
		
		//------------------------------------------------------------
		
		case 0 :                                   // first case when cars is green and pedestrian is red
		while( counting < five_seconds ){          // increment 10 times of .5 to reach 5 seconds
 14e:	60 91 62 00 	lds	r22, 0x0062	; 0x800062 <counting>
 152:	70 91 63 00 	lds	r23, 0x0063	; 0x800063 <counting+0x1>
 156:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <counting+0x2>
 15a:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <counting+0x3>
 15e:	20 e0       	ldi	r18, 0x00	; 0
 160:	30 e0       	ldi	r19, 0x00	; 0
 162:	40 ea       	ldi	r20, 0xA0	; 160
 164:	50 e4       	ldi	r21, 0x40	; 64
 166:	0e 94 50 04 	call	0x8a0	; 0x8a0 <__cmpsf2>
 16a:	88 23       	and	r24, r24
 16c:	54 f2       	brlt	.-108    	; 0x102 <app_start+0x66>
		Led_on(port_B , 2);
        Timer0_Delay_half_second();                // delay .5 second
		counting = counting + .5;
			}
		}
		counting = 0;
 16e:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <counting>
 172:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <counting+0x1>
 176:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <counting+0x2>
 17a:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <counting+0x3>
		Led_off(port_A , 0);
 17e:	60 e0       	ldi	r22, 0x00	; 0
 180:	81 e4       	ldi	r24, 0x41	; 65
 182:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		Led_off(port_B , 2);
 186:	62 e0       	ldi	r22, 0x02	; 2
 188:	82 e4       	ldi	r24, 0x42	; 66
 18a:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		
		state = 1 ;
 18e:	81 e0       	ldi	r24, 0x01	; 1
 190:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <state>
		break;
 194:	a9 cf       	rjmp	.-174    	; 0xe8 <app_start+0x4c>

		// ------------------------------------------------------------

	    case 1 :                                     // first case when cars is yellow and pedestrian is yellow
		while( counting < five_seconds ){            // increment 10 times of .5 to reach 5 seconds
			if (check_push_yellow == 1)              // if interrupt while yellow leds are on then reset counting
 196:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 19a:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 19e:	01 97       	sbiw	r24, 0x01	; 1
 1a0:	79 f4       	brne	.+30     	; 0x1c0 <app_start+0x124>
			{
				counting = 0;
 1a2:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <counting>
 1a6:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <counting+0x1>
 1aa:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <counting+0x2>
 1ae:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <counting+0x3>
				Timer0_Stop();
 1b2:	0e 94 76 03 	call	0x6ec	; 0x6ec <Timer0_Stop>
				check_push_yellow = 0; 
 1b6:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 1ba:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
				goto breaking1;
 1be:	94 cf       	rjmp	.-216    	; 0xe8 <app_start+0x4c>
			}
			else                                     // no interrupt then go back to normal function
			{
		Led_toggle(port_A , 1);
 1c0:	61 e0       	ldi	r22, 0x01	; 1
 1c2:	81 e4       	ldi	r24, 0x41	; 65
 1c4:	0e 94 18 02 	call	0x430	; 0x430 <Led_toggle>
		Led_toggle(port_B , 1);
 1c8:	61 e0       	ldi	r22, 0x01	; 1
 1ca:	82 e4       	ldi	r24, 0x42	; 66
 1cc:	0e 94 18 02 	call	0x430	; 0x430 <Led_toggle>
		Timer0_Delay_half_second();                 // delay .5 second
 1d0:	0e 94 9b 03 	call	0x736	; 0x736 <Timer0_Delay_half_second>
		counting = counting + .5;
 1d4:	60 91 62 00 	lds	r22, 0x0062	; 0x800062 <counting>
 1d8:	70 91 63 00 	lds	r23, 0x0063	; 0x800063 <counting+0x1>
 1dc:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <counting+0x2>
 1e0:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <counting+0x3>
 1e4:	20 e0       	ldi	r18, 0x00	; 0
 1e6:	30 e0       	ldi	r19, 0x00	; 0
 1e8:	40 e0       	ldi	r20, 0x00	; 0
 1ea:	5f e3       	ldi	r21, 0x3F	; 63
 1ec:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <__addsf3>
 1f0:	60 93 62 00 	sts	0x0062, r22	; 0x800062 <counting>
 1f4:	70 93 63 00 	sts	0x0063, r23	; 0x800063 <counting+0x1>
 1f8:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <counting+0x2>
 1fc:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <counting+0x3>
		break;

		// ------------------------------------------------------------

	    case 1 :                                     // first case when cars is yellow and pedestrian is yellow
		while( counting < five_seconds ){            // increment 10 times of .5 to reach 5 seconds
 200:	60 91 62 00 	lds	r22, 0x0062	; 0x800062 <counting>
 204:	70 91 63 00 	lds	r23, 0x0063	; 0x800063 <counting+0x1>
 208:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <counting+0x2>
 20c:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <counting+0x3>
 210:	20 e0       	ldi	r18, 0x00	; 0
 212:	30 e0       	ldi	r19, 0x00	; 0
 214:	40 ea       	ldi	r20, 0xA0	; 160
 216:	50 e4       	ldi	r21, 0x40	; 64
 218:	0e 94 50 04 	call	0x8a0	; 0x8a0 <__cmpsf2>
 21c:	88 23       	and	r24, r24
 21e:	0c f4       	brge	.+2      	; 0x222 <app_start+0x186>
 220:	ba cf       	rjmp	.-140    	; 0x196 <app_start+0xfa>
		Led_toggle(port_B , 1);
		Timer0_Delay_half_second();                 // delay .5 second
		counting = counting + .5;
			}
		}
		counting = 0;
 222:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <counting>
 226:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <counting+0x1>
 22a:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <counting+0x2>
 22e:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <counting+0x3>
		Led_off(port_A , 1);
 232:	61 e0       	ldi	r22, 0x01	; 1
 234:	81 e4       	ldi	r24, 0x41	; 65
 236:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		Led_off(port_B , 1);
 23a:	61 e0       	ldi	r22, 0x01	; 1
 23c:	82 e4       	ldi	r24, 0x42	; 66
 23e:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		
		state = 2;
 242:	82 e0       	ldi	r24, 0x02	; 2
 244:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <state>
 248:	4f cf       	rjmp	.-354    	; 0xe8 <app_start+0x4c>
		break;
		
		//-------------------------------------------------------------
		
	    case 2 :                                     // first case when cars is red and pedestrian is green
		Led_on(port_A , 2);
 24a:	62 e0       	ldi	r22, 0x02	; 2
 24c:	81 e4       	ldi	r24, 0x41	; 65
 24e:	0e 94 10 02 	call	0x420	; 0x420 <Led_on>
		Led_on(port_B , 0);
 252:	60 e0       	ldi	r22, 0x00	; 0
 254:	82 e4       	ldi	r24, 0x42	; 66
 256:	0e 94 10 02 	call	0x420	; 0x420 <Led_on>
		Timer0_Delay_5s();   // delay 5 seconds
 25a:	0e 94 94 03 	call	0x728	; 0x728 <Timer0_Delay_5s>
		Led_off(port_A , 2);
 25e:	62 e0       	ldi	r22, 0x02	; 2
 260:	81 e4       	ldi	r24, 0x41	; 65
 262:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		Led_off(port_B , 0);
 266:	60 e0       	ldi	r22, 0x00	; 0
 268:	82 e4       	ldi	r24, 0x42	; 66
 26a:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		
		state = 3;
 26e:	83 e0       	ldi	r24, 0x03	; 3
 270:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <state>
		break;
 274:	39 cf       	rjmp	.-398    	; 0xe8 <app_start+0x4c>
		
		//-------------------------------------------------------------
		
		case 3:                                             // first case when cars is yellow and pedestrian is yellow
		while( counting < five_seconds ){                   // increment 10 times of .5 to reach 5 seconds
			if (check_push_yellow == 1){                     // if interrupt while yellow leds are on then reset counting			{
 276:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 27a:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 27e:	01 97       	sbiw	r24, 0x01	; 1
 280:	79 f4       	brne	.+30     	; 0x2a0 <app_start+0x204>
				counting = 0;
 282:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <counting>
 286:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <counting+0x1>
 28a:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <counting+0x2>
 28e:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <counting+0x3>
				Timer0_Stop();
 292:	0e 94 76 03 	call	0x6ec	; 0x6ec <Timer0_Stop>
				check_push_yellow = 0;
 296:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 29a:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
				goto breaking2;
 29e:	24 cf       	rjmp	.-440    	; 0xe8 <app_start+0x4c>
			}
			else
			{
			Led_toggle(port_A , 1);
 2a0:	61 e0       	ldi	r22, 0x01	; 1
 2a2:	81 e4       	ldi	r24, 0x41	; 65
 2a4:	0e 94 18 02 	call	0x430	; 0x430 <Led_toggle>
			Led_toggle(port_B , 1);
 2a8:	61 e0       	ldi	r22, 0x01	; 1
 2aa:	82 e4       	ldi	r24, 0x42	; 66
 2ac:	0e 94 18 02 	call	0x430	; 0x430 <Led_toggle>
			Timer0_Delay_half_second();             // delay .5 second
 2b0:	0e 94 9b 03 	call	0x736	; 0x736 <Timer0_Delay_half_second>
			counting = counting + .5;
 2b4:	60 91 62 00 	lds	r22, 0x0062	; 0x800062 <counting>
 2b8:	70 91 63 00 	lds	r23, 0x0063	; 0x800063 <counting+0x1>
 2bc:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <counting+0x2>
 2c0:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <counting+0x3>
 2c4:	20 e0       	ldi	r18, 0x00	; 0
 2c6:	30 e0       	ldi	r19, 0x00	; 0
 2c8:	40 e0       	ldi	r20, 0x00	; 0
 2ca:	5f e3       	ldi	r21, 0x3F	; 63
 2cc:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <__addsf3>
 2d0:	60 93 62 00 	sts	0x0062, r22	; 0x800062 <counting>
 2d4:	70 93 63 00 	sts	0x0063, r23	; 0x800063 <counting+0x1>
 2d8:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <counting+0x2>
 2dc:	90 93 65 00 	sts	0x0065, r25	; 0x800065 <counting+0x3>
		break;
		
		//-------------------------------------------------------------
		
		case 3:                                             // first case when cars is yellow and pedestrian is yellow
		while( counting < five_seconds ){                   // increment 10 times of .5 to reach 5 seconds
 2e0:	60 91 62 00 	lds	r22, 0x0062	; 0x800062 <counting>
 2e4:	70 91 63 00 	lds	r23, 0x0063	; 0x800063 <counting+0x1>
 2e8:	80 91 64 00 	lds	r24, 0x0064	; 0x800064 <counting+0x2>
 2ec:	90 91 65 00 	lds	r25, 0x0065	; 0x800065 <counting+0x3>
 2f0:	20 e0       	ldi	r18, 0x00	; 0
 2f2:	30 e0       	ldi	r19, 0x00	; 0
 2f4:	40 ea       	ldi	r20, 0xA0	; 160
 2f6:	50 e4       	ldi	r21, 0x40	; 64
 2f8:	0e 94 50 04 	call	0x8a0	; 0x8a0 <__cmpsf2>
 2fc:	88 23       	and	r24, r24
 2fe:	0c f4       	brge	.+2      	; 0x302 <app_start+0x266>
 300:	ba cf       	rjmp	.-140    	; 0x276 <app_start+0x1da>
			Led_toggle(port_B , 1);
			Timer0_Delay_half_second();             // delay .5 second
			counting = counting + .5;
			}
		}
		counting = 0;
 302:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <counting>
 306:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <counting+0x1>
 30a:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <counting+0x2>
 30e:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <counting+0x3>
		Led_off(port_A , 1);
 312:	61 e0       	ldi	r22, 0x01	; 1
 314:	81 e4       	ldi	r24, 0x41	; 65
 316:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		Led_off(port_B , 1);
 31a:	61 e0       	ldi	r22, 0x01	; 1
 31c:	82 e4       	ldi	r24, 0x42	; 66
 31e:	0e 94 14 02 	call	0x428	; 0x428 <Led_off>
		
		state = 0 ;
 322:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <state>
 326:	e0 ce       	rjmp	.-576    	; 0xe8 <app_start+0x4c>

00000328 <__vector_1>:
	
}



ISR(INT_0){               // interrupt when pressing the push button
 328:	1f 92       	push	r1
 32a:	0f 92       	push	r0
 32c:	0f b6       	in	r0, 0x3f	; 63
 32e:	0f 92       	push	r0
 330:	11 24       	eor	r1, r1
 332:	2f 93       	push	r18
 334:	3f 93       	push	r19
 336:	4f 93       	push	r20
 338:	5f 93       	push	r21
 33a:	6f 93       	push	r22
 33c:	7f 93       	push	r23
 33e:	8f 93       	push	r24
 340:	9f 93       	push	r25
 342:	af 93       	push	r26
 344:	bf 93       	push	r27
 346:	ef 93       	push	r30
 348:	ff 93       	push	r31
	
	button ++;
 34a:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <button>
 34e:	8f 5f       	subi	r24, 0xFF	; 255
 350:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <button>
	
	switch(button){
 354:	81 30       	cpi	r24, 0x01	; 1
 356:	19 f0       	breq	.+6      	; 0x35e <__vector_1+0x36>
 358:	82 30       	cpi	r24, 0x02	; 2
 35a:	39 f0       	breq	.+14     	; 0x36a <__vector_1+0x42>
 35c:	35 c0       	rjmp	.+106    	; 0x3c8 <__vector_1+0xa0>
	
	case 1:                                // set timer 0 to compare number of overflows with 30 (.5 second)
    Timer2_cl_source( clk_64 );            // set prescaller to 64
 35e:	83 e0       	ldi	r24, 0x03	; 3
 360:	0e 94 b9 03 	call	0x772	; 0x772 <Timer2_cl_source>
	TCNT2 = 47;                            // initiate timer 0 with 47
 364:	8f e2       	ldi	r24, 0x2F	; 47
 366:	84 bd       	out	0x24, r24	; 36
	break;
 368:	2f c0       	rjmp	.+94     	; 0x3c8 <__vector_1+0xa0>
	
	case 2:                          
	if (counting2 > 30 ){                // if still pressing the button after .5 second nothing will happen
 36a:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <counting2>
 36e:	90 91 67 00 	lds	r25, 0x0067	; 0x800067 <counting2+0x1>
 372:	4f 97       	sbiw	r24, 0x1f	; 31
 374:	48 f5       	brcc	.+82     	; 0x3c8 <__vector_1+0xa0>
		// do nothing
	} 
	
	else{                                // go to state 1 (yellow state)
    
	if (state == 0){
 376:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <state>
 37a:	81 11       	cpse	r24, r1
 37c:	0c c0       	rjmp	.+24     	; 0x396 <__vector_1+0x6e>

		state = 1;
 37e:	81 e0       	ldi	r24, 0x01	; 1
 380:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <state>
		counting = 0;
 384:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <counting>
 388:	10 92 63 00 	sts	0x0063, r1	; 0x800063 <counting+0x1>
 38c:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <counting+0x2>
 390:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <counting+0x3>
 394:	11 c0       	rjmp	.+34     	; 0x3b8 <__vector_1+0x90>
	}
	else if(state == 1 ){              // if state = 1 (yellow state)  then reset timer to start delay with 0 sec until it goes to 5 sec
 396:	81 30       	cpi	r24, 0x01	; 1
 398:	39 f4       	brne	.+14     	; 0x3a8 <__vector_1+0x80>
		check_push_yellow = 1;
 39a:	81 e0       	ldi	r24, 0x01	; 1
 39c:	90 e0       	ldi	r25, 0x00	; 0
 39e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 3a2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
 3a6:	08 c0       	rjmp	.+16     	; 0x3b8 <__vector_1+0x90>
	}
	else if(state == 3 ){              // if state = 3 (yellow state)  then reset timer to start delay with 0 sec until it goes to 5 sec
 3a8:	83 30       	cpi	r24, 0x03	; 3
 3aa:	31 f4       	brne	.+12     	; 0x3b8 <__vector_1+0x90>
		check_push_yellow = 1;
 3ac:	81 e0       	ldi	r24, 0x01	; 1
 3ae:	90 e0       	ldi	r25, 0x00	; 0
 3b0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 3b4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
	}
	else{
		// do nothing
	}
	
    Timer2_Stop();   //
 3b8:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <Timer2_Stop>
	counting2 = 0; // reset all
 3bc:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <counting2+0x1>
 3c0:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <counting2>
	button = 0 ;     //
 3c4:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <button>
	break;
	}
	}
}
 3c8:	ff 91       	pop	r31
 3ca:	ef 91       	pop	r30
 3cc:	bf 91       	pop	r27
 3ce:	af 91       	pop	r26
 3d0:	9f 91       	pop	r25
 3d2:	8f 91       	pop	r24
 3d4:	7f 91       	pop	r23
 3d6:	6f 91       	pop	r22
 3d8:	5f 91       	pop	r21
 3da:	4f 91       	pop	r20
 3dc:	3f 91       	pop	r19
 3de:	2f 91       	pop	r18
 3e0:	0f 90       	pop	r0
 3e2:	0f be       	out	0x3f, r0	; 63
 3e4:	0f 90       	pop	r0
 3e6:	1f 90       	pop	r1
 3e8:	18 95       	reti

000003ea <__vector_5>:

ISR(TIMER2_OVF)
{
 3ea:	1f 92       	push	r1
 3ec:	0f 92       	push	r0
 3ee:	0f b6       	in	r0, 0x3f	; 63
 3f0:	0f 92       	push	r0
 3f2:	11 24       	eor	r1, r1
 3f4:	8f 93       	push	r24
 3f6:	9f 93       	push	r25
	counting2++; // increment overflow
 3f8:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <counting2>
 3fc:	90 91 67 00 	lds	r25, 0x0067	; 0x800067 <counting2+0x1>
 400:	01 96       	adiw	r24, 0x01	; 1
 402:	90 93 67 00 	sts	0x0067, r25	; 0x800067 <counting2+0x1>
 406:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <counting2>
 40a:	9f 91       	pop	r25
 40c:	8f 91       	pop	r24
 40e:	0f 90       	pop	r0
 410:	0f be       	out	0x3f, r0	; 63
 412:	0f 90       	pop	r0
 414:	1f 90       	pop	r1
 416:	18 95       	reti

00000418 <Led_init>:

// Set the direction of led >> input or output

void Led_init(uint8_t led_Port , uint8_t Led_Pin){
	
	Dio_init(led_Port , Led_Pin , OUT); // Set direction of pin referred from led
 418:	41 e0       	ldi	r20, 0x01	; 1
 41a:	0e 94 24 02 	call	0x448	; 0x448 <Dio_init>
 41e:	08 95       	ret

00000420 <Led_on>:

//  Initiate the led to make it on (lighted)

void Led_on(uint8_t led_Port , uint8_t Led_Pin){
	
	Dio_Write(led_Port , Led_Pin , 1); // Set high in pin referred from led
 420:	41 e0       	ldi	r20, 0x01	; 1
 422:	0e 94 78 02 	call	0x4f0	; 0x4f0 <Dio_Write>
 426:	08 95       	ret

00000428 <Led_off>:

//  Initiate the led to make it off

void Led_off(uint8_t led_Port , uint8_t Led_Pin){
	
	Dio_Write(led_Port , Led_Pin , 0); // Set low in pin referred from led
 428:	40 e0       	ldi	r20, 0x00	; 0
 42a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <Dio_Write>
 42e:	08 95       	ret

00000430 <Led_toggle>:

//  Initiate the led to make it toggle (lighted and off)

void Led_toggle(uint8_t led_Port , uint8_t Led_Pin){
	
	Dio_Toggle(led_Port, Led_Pin); // toggle pin referred from led
 430:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <Dio_Toggle>
 434:	08 95       	ret

00000436 <Button_Init>:
#include "Button.h"

// Set the direction of button >> input or output
void Button_Init(uint8_t Button_Port , uint8_t Button_Pin){
	
	Dio_init (Button_Port , Button_Pin , IN); // Set direction of pin referred from Button
 436:	40 e0       	ldi	r20, 0x00	; 0
 438:	0e 94 24 02 	call	0x448	; 0x448 <Dio_init>
 43c:	08 95       	ret

0000043e <main>:
#include "Application/app.h"

int main ()
{	
	// start program in application
		app_start();
 43e:	0e 94 4e 00 	call	0x9c	; 0x9c <app_start>
	
}
 442:	80 e0       	ldi	r24, 0x00	; 0
 444:	90 e0       	ldi	r25, 0x00	; 0
 446:	08 95       	ret

00000448 <Dio_init>:
			case port_D:
			*value = (PIND & (1<<Pin_Number))>> Pin_Number;
			break;
			
			case port_B:
			*value = (PINB & (1<<Pin_Number))>> Pin_Number;
 448:	82 34       	cpi	r24, 0x42	; 66
 44a:	e1 f0       	breq	.+56     	; 0x484 <Dio_init+0x3c>
 44c:	18 f4       	brcc	.+6      	; 0x454 <Dio_init+0xc>
 44e:	81 34       	cpi	r24, 0x41	; 65
 450:	31 f0       	breq	.+12     	; 0x45e <Dio_init+0x16>
 452:	08 95       	ret
 454:	83 34       	cpi	r24, 0x43	; 67
 456:	41 f1       	breq	.+80     	; 0x4a8 <Dio_init+0x60>
 458:	84 34       	cpi	r24, 0x44	; 68
 45a:	c1 f1       	breq	.+112    	; 0x4cc <Dio_init+0x84>
 45c:	08 95       	ret
 45e:	41 11       	cpse	r20, r1
 460:	03 c0       	rjmp	.+6      	; 0x468 <Dio_init+0x20>
 462:	8a b3       	in	r24, 0x1a	; 26
 464:	8a bb       	out	0x1a, r24	; 26
 466:	08 95       	ret
 468:	41 30       	cpi	r20, 0x01	; 1
 46a:	09 f0       	breq	.+2      	; 0x46e <Dio_init+0x26>
 46c:	40 c0       	rjmp	.+128    	; 0x4ee <Dio_init+0xa6>
 46e:	2a b3       	in	r18, 0x1a	; 26
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	90 e0       	ldi	r25, 0x00	; 0
 474:	02 c0       	rjmp	.+4      	; 0x47a <Dio_init+0x32>
 476:	88 0f       	add	r24, r24
 478:	99 1f       	adc	r25, r25
 47a:	6a 95       	dec	r22
 47c:	e2 f7       	brpl	.-8      	; 0x476 <Dio_init+0x2e>
 47e:	82 2b       	or	r24, r18
 480:	8a bb       	out	0x1a, r24	; 26
 482:	08 95       	ret
 484:	41 11       	cpse	r20, r1
 486:	03 c0       	rjmp	.+6      	; 0x48e <Dio_init+0x46>
 488:	87 b3       	in	r24, 0x17	; 23
 48a:	87 bb       	out	0x17, r24	; 23
 48c:	08 95       	ret
 48e:	41 30       	cpi	r20, 0x01	; 1
 490:	71 f5       	brne	.+92     	; 0x4ee <Dio_init+0xa6>
 492:	27 b3       	in	r18, 0x17	; 23
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	90 e0       	ldi	r25, 0x00	; 0
 498:	02 c0       	rjmp	.+4      	; 0x49e <Dio_init+0x56>
 49a:	88 0f       	add	r24, r24
 49c:	99 1f       	adc	r25, r25
 49e:	6a 95       	dec	r22
 4a0:	e2 f7       	brpl	.-8      	; 0x49a <Dio_init+0x52>
 4a2:	82 2b       	or	r24, r18
 4a4:	87 bb       	out	0x17, r24	; 23
 4a6:	08 95       	ret
 4a8:	41 11       	cpse	r20, r1
 4aa:	03 c0       	rjmp	.+6      	; 0x4b2 <Dio_init+0x6a>
 4ac:	84 b3       	in	r24, 0x14	; 20
 4ae:	84 bb       	out	0x14, r24	; 20
 4b0:	08 95       	ret
 4b2:	41 30       	cpi	r20, 0x01	; 1
 4b4:	e1 f4       	brne	.+56     	; 0x4ee <Dio_init+0xa6>
 4b6:	24 b3       	in	r18, 0x14	; 20
 4b8:	81 e0       	ldi	r24, 0x01	; 1
 4ba:	90 e0       	ldi	r25, 0x00	; 0
 4bc:	02 c0       	rjmp	.+4      	; 0x4c2 <Dio_init+0x7a>
 4be:	88 0f       	add	r24, r24
 4c0:	99 1f       	adc	r25, r25
 4c2:	6a 95       	dec	r22
 4c4:	e2 f7       	brpl	.-8      	; 0x4be <Dio_init+0x76>
 4c6:	82 2b       	or	r24, r18
 4c8:	84 bb       	out	0x14, r24	; 20
 4ca:	08 95       	ret
 4cc:	41 11       	cpse	r20, r1
 4ce:	03 c0       	rjmp	.+6      	; 0x4d6 <Dio_init+0x8e>
 4d0:	81 b3       	in	r24, 0x11	; 17
 4d2:	81 bb       	out	0x11, r24	; 17
 4d4:	08 95       	ret
 4d6:	41 30       	cpi	r20, 0x01	; 1
 4d8:	51 f4       	brne	.+20     	; 0x4ee <Dio_init+0xa6>
 4da:	21 b3       	in	r18, 0x11	; 17
 4dc:	81 e0       	ldi	r24, 0x01	; 1
 4de:	90 e0       	ldi	r25, 0x00	; 0
 4e0:	02 c0       	rjmp	.+4      	; 0x4e6 <Dio_init+0x9e>
 4e2:	88 0f       	add	r24, r24
 4e4:	99 1f       	adc	r25, r25
 4e6:	6a 95       	dec	r22
 4e8:	e2 f7       	brpl	.-8      	; 0x4e2 <Dio_init+0x9a>
 4ea:	82 2b       	or	r24, r18
 4ec:	81 bb       	out	0x11, r24	; 17
 4ee:	08 95       	ret

000004f0 <Dio_Write>:
 4f0:	82 34       	cpi	r24, 0x42	; 66
 4f2:	31 f1       	breq	.+76     	; 0x540 <Dio_Write+0x50>
 4f4:	18 f4       	brcc	.+6      	; 0x4fc <Dio_Write+0xc>
 4f6:	81 34       	cpi	r24, 0x41	; 65
 4f8:	39 f0       	breq	.+14     	; 0x508 <Dio_Write+0x18>
 4fa:	08 95       	ret
 4fc:	83 34       	cpi	r24, 0x43	; 67
 4fe:	e1 f1       	breq	.+120    	; 0x578 <Dio_Write+0x88>
 500:	84 34       	cpi	r24, 0x44	; 68
 502:	09 f4       	brne	.+2      	; 0x506 <Dio_Write+0x16>
 504:	54 c0       	rjmp	.+168    	; 0x5ae <Dio_Write+0xbe>
 506:	08 95       	ret
 508:	41 11       	cpse	r20, r1
 50a:	0c c0       	rjmp	.+24     	; 0x524 <Dio_Write+0x34>
 50c:	2b b3       	in	r18, 0x1b	; 27
 50e:	81 e0       	ldi	r24, 0x01	; 1
 510:	90 e0       	ldi	r25, 0x00	; 0
 512:	02 c0       	rjmp	.+4      	; 0x518 <Dio_Write+0x28>
 514:	88 0f       	add	r24, r24
 516:	99 1f       	adc	r25, r25
 518:	6a 95       	dec	r22
 51a:	e2 f7       	brpl	.-8      	; 0x514 <Dio_Write+0x24>
 51c:	80 95       	com	r24
 51e:	82 23       	and	r24, r18
 520:	8b bb       	out	0x1b, r24	; 27
 522:	08 95       	ret
 524:	41 30       	cpi	r20, 0x01	; 1
 526:	09 f0       	breq	.+2      	; 0x52a <Dio_Write+0x3a>
 528:	5c c0       	rjmp	.+184    	; 0x5e2 <Dio_Write+0xf2>
 52a:	2b b3       	in	r18, 0x1b	; 27
 52c:	81 e0       	ldi	r24, 0x01	; 1
 52e:	90 e0       	ldi	r25, 0x00	; 0
 530:	02 c0       	rjmp	.+4      	; 0x536 <Dio_Write+0x46>
 532:	88 0f       	add	r24, r24
 534:	99 1f       	adc	r25, r25
 536:	6a 95       	dec	r22
 538:	e2 f7       	brpl	.-8      	; 0x532 <Dio_Write+0x42>
 53a:	82 2b       	or	r24, r18
 53c:	8b bb       	out	0x1b, r24	; 27
 53e:	08 95       	ret
 540:	41 11       	cpse	r20, r1
 542:	0c c0       	rjmp	.+24     	; 0x55c <Dio_Write+0x6c>
 544:	28 b3       	in	r18, 0x18	; 24
 546:	81 e0       	ldi	r24, 0x01	; 1
 548:	90 e0       	ldi	r25, 0x00	; 0
 54a:	02 c0       	rjmp	.+4      	; 0x550 <Dio_Write+0x60>
 54c:	88 0f       	add	r24, r24
 54e:	99 1f       	adc	r25, r25
 550:	6a 95       	dec	r22
 552:	e2 f7       	brpl	.-8      	; 0x54c <Dio_Write+0x5c>
 554:	80 95       	com	r24
 556:	82 23       	and	r24, r18
 558:	88 bb       	out	0x18, r24	; 24
 55a:	08 95       	ret
 55c:	41 30       	cpi	r20, 0x01	; 1
 55e:	09 f0       	breq	.+2      	; 0x562 <Dio_Write+0x72>
 560:	40 c0       	rjmp	.+128    	; 0x5e2 <Dio_Write+0xf2>
 562:	28 b3       	in	r18, 0x18	; 24
 564:	81 e0       	ldi	r24, 0x01	; 1
 566:	90 e0       	ldi	r25, 0x00	; 0
 568:	02 c0       	rjmp	.+4      	; 0x56e <Dio_Write+0x7e>
 56a:	88 0f       	add	r24, r24
 56c:	99 1f       	adc	r25, r25
 56e:	6a 95       	dec	r22
 570:	e2 f7       	brpl	.-8      	; 0x56a <Dio_Write+0x7a>
 572:	82 2b       	or	r24, r18
 574:	88 bb       	out	0x18, r24	; 24
 576:	08 95       	ret
 578:	41 11       	cpse	r20, r1
 57a:	0c c0       	rjmp	.+24     	; 0x594 <Dio_Write+0xa4>
 57c:	25 b3       	in	r18, 0x15	; 21
 57e:	81 e0       	ldi	r24, 0x01	; 1
 580:	90 e0       	ldi	r25, 0x00	; 0
 582:	02 c0       	rjmp	.+4      	; 0x588 <Dio_Write+0x98>
 584:	88 0f       	add	r24, r24
 586:	99 1f       	adc	r25, r25
 588:	6a 95       	dec	r22
 58a:	e2 f7       	brpl	.-8      	; 0x584 <Dio_Write+0x94>
 58c:	80 95       	com	r24
 58e:	82 23       	and	r24, r18
 590:	85 bb       	out	0x15, r24	; 21
 592:	08 95       	ret
 594:	41 30       	cpi	r20, 0x01	; 1
 596:	29 f5       	brne	.+74     	; 0x5e2 <Dio_Write+0xf2>
 598:	25 b3       	in	r18, 0x15	; 21
 59a:	81 e0       	ldi	r24, 0x01	; 1
 59c:	90 e0       	ldi	r25, 0x00	; 0
 59e:	02 c0       	rjmp	.+4      	; 0x5a4 <Dio_Write+0xb4>
 5a0:	88 0f       	add	r24, r24
 5a2:	99 1f       	adc	r25, r25
 5a4:	6a 95       	dec	r22
 5a6:	e2 f7       	brpl	.-8      	; 0x5a0 <Dio_Write+0xb0>
 5a8:	82 2b       	or	r24, r18
 5aa:	85 bb       	out	0x15, r24	; 21
 5ac:	08 95       	ret
 5ae:	41 11       	cpse	r20, r1
 5b0:	0c c0       	rjmp	.+24     	; 0x5ca <Dio_Write+0xda>
 5b2:	22 b3       	in	r18, 0x12	; 18
 5b4:	81 e0       	ldi	r24, 0x01	; 1
 5b6:	90 e0       	ldi	r25, 0x00	; 0
 5b8:	02 c0       	rjmp	.+4      	; 0x5be <Dio_Write+0xce>
 5ba:	88 0f       	add	r24, r24
 5bc:	99 1f       	adc	r25, r25
 5be:	6a 95       	dec	r22
 5c0:	e2 f7       	brpl	.-8      	; 0x5ba <Dio_Write+0xca>
 5c2:	80 95       	com	r24
 5c4:	82 23       	and	r24, r18
 5c6:	82 bb       	out	0x12, r24	; 18
 5c8:	08 95       	ret
 5ca:	41 30       	cpi	r20, 0x01	; 1
 5cc:	51 f4       	brne	.+20     	; 0x5e2 <Dio_Write+0xf2>
 5ce:	22 b3       	in	r18, 0x12	; 18
 5d0:	81 e0       	ldi	r24, 0x01	; 1
 5d2:	90 e0       	ldi	r25, 0x00	; 0
 5d4:	02 c0       	rjmp	.+4      	; 0x5da <Dio_Write+0xea>
 5d6:	88 0f       	add	r24, r24
 5d8:	99 1f       	adc	r25, r25
 5da:	6a 95       	dec	r22
 5dc:	e2 f7       	brpl	.-8      	; 0x5d6 <Dio_Write+0xe6>
 5de:	82 2b       	or	r24, r18
 5e0:	82 bb       	out	0x12, r24	; 18
 5e2:	08 95       	ret

000005e4 <Dio_Toggle>:
	
	// toggle any pin (low and high)
void Dio_Toggle(uint8_t  Port_Letter , uint8_t  Pin_Number)
{
	
	switch (Port_Letter)
 5e4:	82 34       	cpi	r24, 0x42	; 66
 5e6:	a1 f0       	breq	.+40     	; 0x610 <Dio_Toggle+0x2c>
 5e8:	18 f4       	brcc	.+6      	; 0x5f0 <Dio_Toggle+0xc>
 5ea:	81 34       	cpi	r24, 0x41	; 65
 5ec:	31 f0       	breq	.+12     	; 0x5fa <Dio_Toggle+0x16>
 5ee:	08 95       	ret
 5f0:	83 34       	cpi	r24, 0x43	; 67
 5f2:	c9 f0       	breq	.+50     	; 0x626 <Dio_Toggle+0x42>
 5f4:	84 34       	cpi	r24, 0x44	; 68
 5f6:	11 f1       	breq	.+68     	; 0x63c <Dio_Toggle+0x58>
 5f8:	08 95       	ret
	{
		case port_A:
		PORTA ^= (1<<Pin_Number);
 5fa:	2b b3       	in	r18, 0x1b	; 27
 5fc:	81 e0       	ldi	r24, 0x01	; 1
 5fe:	90 e0       	ldi	r25, 0x00	; 0
 600:	02 c0       	rjmp	.+4      	; 0x606 <Dio_Toggle+0x22>
 602:	88 0f       	add	r24, r24
 604:	99 1f       	adc	r25, r25
 606:	6a 95       	dec	r22
 608:	e2 f7       	brpl	.-8      	; 0x602 <Dio_Toggle+0x1e>
 60a:	82 27       	eor	r24, r18
 60c:	8b bb       	out	0x1b, r24	; 27
		break;
 60e:	08 95       	ret
		
		case port_B:
		PORTB ^=(1<<Pin_Number);
 610:	28 b3       	in	r18, 0x18	; 24
 612:	81 e0       	ldi	r24, 0x01	; 1
 614:	90 e0       	ldi	r25, 0x00	; 0
 616:	02 c0       	rjmp	.+4      	; 0x61c <Dio_Toggle+0x38>
 618:	88 0f       	add	r24, r24
 61a:	99 1f       	adc	r25, r25
 61c:	6a 95       	dec	r22
 61e:	e2 f7       	brpl	.-8      	; 0x618 <Dio_Toggle+0x34>
 620:	82 27       	eor	r24, r18
 622:	88 bb       	out	0x18, r24	; 24
		break;
 624:	08 95       	ret
		
		case port_C:
		PORTC ^=(1<<Pin_Number);
 626:	25 b3       	in	r18, 0x15	; 21
 628:	81 e0       	ldi	r24, 0x01	; 1
 62a:	90 e0       	ldi	r25, 0x00	; 0
 62c:	02 c0       	rjmp	.+4      	; 0x632 <Dio_Toggle+0x4e>
 62e:	88 0f       	add	r24, r24
 630:	99 1f       	adc	r25, r25
 632:	6a 95       	dec	r22
 634:	e2 f7       	brpl	.-8      	; 0x62e <Dio_Toggle+0x4a>
 636:	82 27       	eor	r24, r18
 638:	85 bb       	out	0x15, r24	; 21
		break;
 63a:	08 95       	ret
		
		case port_D:
		PORTD ^=(1<<Pin_Number);
 63c:	22 b3       	in	r18, 0x12	; 18
 63e:	81 e0       	ldi	r24, 0x01	; 1
 640:	90 e0       	ldi	r25, 0x00	; 0
 642:	02 c0       	rjmp	.+4      	; 0x648 <Dio_Toggle+0x64>
 644:	88 0f       	add	r24, r24
 646:	99 1f       	adc	r25, r25
 648:	6a 95       	dec	r22
 64a:	e2 f7       	brpl	.-8      	; 0x644 <Dio_Toggle+0x60>
 64c:	82 27       	eor	r24, r18
 64e:	82 bb       	out	0x12, r24	; 18
 650:	08 95       	ret

00000652 <Interrupt0_Init>:

#include "Interrupt.h"
#include "../../Utilities/Regesters.h"

void Interrupt0_Init(void){
	sei();                                   //  Enable global interrupts
 652:	78 94       	sei
	MCUCR |= (1 << 0); MCUCR |= (0 << 1);            //  logical change
 654:	85 b7       	in	r24, 0x35	; 53
 656:	81 60       	ori	r24, 0x01	; 1
 658:	85 bf       	out	0x35, r24	; 53
 65a:	85 b7       	in	r24, 0x35	; 53
 65c:	85 bf       	out	0x35, r24	; 53
	GICR |= (1 << 6);                        //  Enable External Interrupt (INT0)
 65e:	8b b7       	in	r24, 0x3b	; 59
 660:	80 64       	ori	r24, 0x40	; 64
 662:	8b bf       	out	0x3b, r24	; 59
 664:	08 95       	ret

00000666 <Timer2_InT>:
}

void Timer2_InT(void){
	TIMSK |= (1 << 6);                   // overflow interrupts in timer 2
 666:	89 b7       	in	r24, 0x39	; 57
 668:	80 64       	ori	r24, 0x40	; 64
 66a:	89 bf       	out	0x39, r24	; 57
 66c:	08 95       	ret

0000066e <Timer0_Mode>:
 */ 
#include "Timer.h"

void Timer0_Mode( uint8_t Mode ){        // set the mode Timer0 (Normal or CTC or Phase Shift or Fast PWM) 
	
	switch(Mode){
 66e:	81 30       	cpi	r24, 0x01	; 1
 670:	49 f0       	breq	.+18     	; 0x684 <Timer0_Mode+0x16>
 672:	28 f0       	brcs	.+10     	; 0x67e <Timer0_Mode+0x10>
 674:	82 30       	cpi	r24, 0x02	; 2
 676:	51 f0       	breq	.+20     	; 0x68c <Timer0_Mode+0x1e>
 678:	83 30       	cpi	r24, 0x03	; 3
 67a:	61 f0       	breq	.+24     	; 0x694 <Timer0_Mode+0x26>
 67c:	08 95       	ret
		
		case Normal :
		TCCR0 |= (0<<3) | (0<<6);
 67e:	83 b7       	in	r24, 0x33	; 51
 680:	83 bf       	out	0x33, r24	; 51
		break;
 682:	08 95       	ret
		
		case CTC :
		TCCR0 |= (1<<3) | (0<<6);
 684:	83 b7       	in	r24, 0x33	; 51
 686:	88 60       	ori	r24, 0x08	; 8
 688:	83 bf       	out	0x33, r24	; 51
		break;
 68a:	08 95       	ret
		
		case Phase_Shift :
		TCCR0 |= (0<<3) | (1<<6);
 68c:	83 b7       	in	r24, 0x33	; 51
 68e:	80 64       	ori	r24, 0x40	; 64
 690:	83 bf       	out	0x33, r24	; 51
		break;
 692:	08 95       	ret
		
		case Fast_PWM :
		TCCR0 |= (1<<3) | (1<<6);
 694:	83 b7       	in	r24, 0x33	; 51
 696:	88 64       	ori	r24, 0x48	; 72
 698:	83 bf       	out	0x33, r24	; 51
 69a:	08 95       	ret

0000069c <Timer0_cl_source>:
	
}

void Timer0_cl_source( uint8_t Clk_Source ){    // choose if no prescaller or with prescaller and which type or choose rising edge or falling edge 
	
	switch(Clk_Source){
 69c:	90 e0       	ldi	r25, 0x00	; 0
 69e:	88 30       	cpi	r24, 0x08	; 8
 6a0:	91 05       	cpc	r25, r1
 6a2:	18 f5       	brcc	.+70     	; 0x6ea <Timer0_cl_source+0x4e>
 6a4:	fc 01       	movw	r30, r24
 6a6:	e6 5d       	subi	r30, 0xD6	; 214
 6a8:	ff 4f       	sbci	r31, 0xFF	; 255
 6aa:	0c 94 ca 04 	jmp	0x994	; 0x994 <__tablejump2__>
		
		case  No_clock_source :
		        TCCR0 |= (0 << 0) | (0 << 1) | (0 << 2);
 6ae:	83 b7       	in	r24, 0x33	; 51
 6b0:	83 bf       	out	0x33, r24	; 51
		break;
 6b2:	08 95       	ret
		
		case clk :
				TCCR0 |= (1 << 0) | (0 << 1) | (0 << 2);
 6b4:	83 b7       	in	r24, 0x33	; 51
 6b6:	81 60       	ori	r24, 0x01	; 1
 6b8:	83 bf       	out	0x33, r24	; 51
		break;
 6ba:	08 95       	ret
		
		case clk_8 :
				TCCR0 |= (0 << 0) | (1 << 1) | (0 << 2);
 6bc:	83 b7       	in	r24, 0x33	; 51
 6be:	82 60       	ori	r24, 0x02	; 2
 6c0:	83 bf       	out	0x33, r24	; 51
		break;
 6c2:	08 95       	ret
		
		case clk_64 :
				TCCR0 |= (1 << 0) | (1 << 1) | (0 << 2);
 6c4:	83 b7       	in	r24, 0x33	; 51
 6c6:	83 60       	ori	r24, 0x03	; 3
 6c8:	83 bf       	out	0x33, r24	; 51
		break;
 6ca:	08 95       	ret
		
		case clk_256 :
				TCCR0 |= (0 << 0) | (0 << 1) | (1 << 2);
 6cc:	83 b7       	in	r24, 0x33	; 51
 6ce:	84 60       	ori	r24, 0x04	; 4
 6d0:	83 bf       	out	0x33, r24	; 51
		break;
 6d2:	08 95       	ret
		
		case clk_1024 :
				TCCR0 |= (1 << 0) | (0 << 1) | (1 << 2);
 6d4:	83 b7       	in	r24, 0x33	; 51
 6d6:	85 60       	ori	r24, 0x05	; 5
 6d8:	83 bf       	out	0x33, r24	; 51
		break;
 6da:	08 95       	ret
		
		case falling_edge :
				TCCR0 |= (0 << 0) | (1 << 1) | (1 << 2);
 6dc:	83 b7       	in	r24, 0x33	; 51
 6de:	86 60       	ori	r24, 0x06	; 6
 6e0:	83 bf       	out	0x33, r24	; 51
		break;
 6e2:	08 95       	ret
		
		case rising_edge :
				TCCR0 |= (1 << 0) | (1 << 1) | (1 << 2);
 6e4:	83 b7       	in	r24, 0x33	; 51
 6e6:	87 60       	ori	r24, 0x07	; 7
 6e8:	83 bf       	out	0x33, r24	; 51
 6ea:	08 95       	ret

000006ec <Timer0_Stop>:
	
	
}

void Timer0_Stop(void){       // stop timer 
	TCCR0 = 0;
 6ec:	13 be       	out	0x33, r1	; 51
 6ee:	08 95       	ret

000006f0 <Timer0_Delay>:
1:prescaller type
2:Number of overflows
3:initial value of the timer

*/
void Timer0_Delay(uint8_t Clk_Source , uint32_t Number_Of_OverFlows , uint8_t Initial_Value){  
 6f0:	1f 93       	push	r17
 6f2:	cf 93       	push	r28
 6f4:	df 93       	push	r29
 6f6:	eb 01       	movw	r28, r22
 6f8:	14 2f       	mov	r17, r20
	
	Timer0_cl_source(Clk_Source );
 6fa:	0e 94 4e 03 	call	0x69c	; 0x69c <Timer0_cl_source>
	TCNT0 = Initial_Value;
 6fe:	12 bf       	out	0x32, r17	; 50
	uint32_t Over_Flow   = 0;
 700:	20 e0       	ldi	r18, 0x00	; 0
 702:	30 e0       	ldi	r19, 0x00	; 0
	
	
	while (Over_Flow < Number_Of_OverFlows)
 704:	08 c0       	rjmp	.+16     	; 0x716 <Timer0_Delay+0x26>
	{
		// wait the overflow flat to be set
		while ((TIFR & (1 << 0)) == 0);
 706:	08 b6       	in	r0, 0x38	; 56
 708:	00 fe       	sbrs	r0, 0
 70a:	fd cf       	rjmp	.-6      	; 0x706 <Timer0_Delay+0x16>
		// Clear the overflow flag
		TIFR |= (1 << 0);
 70c:	88 b7       	in	r24, 0x38	; 56
 70e:	81 60       	ori	r24, 0x01	; 1
 710:	88 bf       	out	0x38, r24	; 56
		Over_Flow++;
 712:	2f 5f       	subi	r18, 0xFF	; 255
 714:	3f 4f       	sbci	r19, 0xFF	; 255
	Timer0_cl_source(Clk_Source );
	TCNT0 = Initial_Value;
	uint32_t Over_Flow   = 0;
	
	
	while (Over_Flow < Number_Of_OverFlows)
 716:	2c 17       	cp	r18, r28
 718:	3d 07       	cpc	r19, r29
 71a:	a8 f3       	brcs	.-22     	; 0x706 <Timer0_Delay+0x16>
		Over_Flow++;
	}
	
	
	Over_Flow = 0;
	Timer0_Stop();
 71c:	0e 94 76 03 	call	0x6ec	; 0x6ec <Timer0_Stop>
}
 720:	df 91       	pop	r29
 722:	cf 91       	pop	r28
 724:	1f 91       	pop	r17
 726:	08 95       	ret

00000728 <Timer0_Delay_5s>:

void Timer0_Delay_5s(void){     // delay 5 seconds
	
	Timer0_Delay( clk_1024 , 20 , 237 );
 728:	4d ee       	ldi	r20, 0xED	; 237
 72a:	64 e1       	ldi	r22, 0x14	; 20
 72c:	70 e0       	ldi	r23, 0x00	; 0
 72e:	85 e0       	ldi	r24, 0x05	; 5
 730:	0e 94 78 03 	call	0x6f0	; 0x6f0 <Timer0_Delay>
 734:	08 95       	ret

00000736 <Timer0_Delay_half_second>:
	
}

void Timer0_Delay_half_second(void){
	
	Timer0_Delay( clk_1024 , 2 , 24 );
 736:	48 e1       	ldi	r20, 0x18	; 24
 738:	62 e0       	ldi	r22, 0x02	; 2
 73a:	70 e0       	ldi	r23, 0x00	; 0
 73c:	85 e0       	ldi	r24, 0x05	; 5
 73e:	0e 94 78 03 	call	0x6f0	; 0x6f0 <Timer0_Delay>
 742:	08 95       	ret

00000744 <Timer2_Mode>:
//                                                           Timer 2
// -------------------------------------------------------------------------------------------------------------------------------------------------------------//

void Timer2_Mode( uint8_t Mode ){        // set the mode Timer0 (Normal or CTC or Phase Shift or Fast PWM)
	
	switch(Mode){
 744:	81 30       	cpi	r24, 0x01	; 1
 746:	49 f0       	breq	.+18     	; 0x75a <Timer2_Mode+0x16>
 748:	28 f0       	brcs	.+10     	; 0x754 <Timer2_Mode+0x10>
 74a:	82 30       	cpi	r24, 0x02	; 2
 74c:	51 f0       	breq	.+20     	; 0x762 <Timer2_Mode+0x1e>
 74e:	83 30       	cpi	r24, 0x03	; 3
 750:	61 f0       	breq	.+24     	; 0x76a <Timer2_Mode+0x26>
 752:	08 95       	ret
		
		case Normal :
		TCCR2  |= (0<<3) | (0<<6);
 754:	85 b5       	in	r24, 0x25	; 37
 756:	85 bd       	out	0x25, r24	; 37
		break;
 758:	08 95       	ret
		
		case CTC :
		TCCR2  |= (1<<3) | (0<<6);
 75a:	85 b5       	in	r24, 0x25	; 37
 75c:	88 60       	ori	r24, 0x08	; 8
 75e:	85 bd       	out	0x25, r24	; 37
		break;
 760:	08 95       	ret
		
		case Phase_Shift :
		TCCR2  |= (0<<3) | (1<<6);
 762:	85 b5       	in	r24, 0x25	; 37
 764:	80 64       	ori	r24, 0x40	; 64
 766:	85 bd       	out	0x25, r24	; 37
		break;
 768:	08 95       	ret
		
		case Fast_PWM :
		TCCR2  |= (1<<3) | (1<<6);
 76a:	85 b5       	in	r24, 0x25	; 37
 76c:	88 64       	ori	r24, 0x48	; 72
 76e:	85 bd       	out	0x25, r24	; 37
 770:	08 95       	ret

00000772 <Timer2_cl_source>:
	
}

void Timer2_cl_source( uint8_t Clk_Source ){    // choose if no prescaller or with prescaller and which type or choose rising edge or falling edge
	
	switch(Clk_Source){
 772:	90 e0       	ldi	r25, 0x00	; 0
 774:	88 30       	cpi	r24, 0x08	; 8
 776:	91 05       	cpc	r25, r1
 778:	18 f5       	brcc	.+70     	; 0x7c0 <Timer2_cl_source+0x4e>
 77a:	fc 01       	movw	r30, r24
 77c:	ee 5c       	subi	r30, 0xCE	; 206
 77e:	ff 4f       	sbci	r31, 0xFF	; 255
 780:	0c 94 ca 04 	jmp	0x994	; 0x994 <__tablejump2__>
		
		case  No_clock_source :
		TCCR2 |= (0 << 0) | (0 << 1) | (0 << 2);
 784:	85 b5       	in	r24, 0x25	; 37
 786:	85 bd       	out	0x25, r24	; 37
		break;
 788:	08 95       	ret
		
		case clk :
		TCCR2 |= (1 << 0) | (0 << 1) | (0 << 2);
 78a:	85 b5       	in	r24, 0x25	; 37
 78c:	81 60       	ori	r24, 0x01	; 1
 78e:	85 bd       	out	0x25, r24	; 37
		break;
 790:	08 95       	ret
		
		case clk_8 :
		TCCR2 |= (0 << 0) | (1 << 1) | (0 << 2);
 792:	85 b5       	in	r24, 0x25	; 37
 794:	82 60       	ori	r24, 0x02	; 2
 796:	85 bd       	out	0x25, r24	; 37
		break;
 798:	08 95       	ret
		
		case clk_64 :
		TCCR2 |= (1 << 0) | (1 << 1) | (0 << 2);
 79a:	85 b5       	in	r24, 0x25	; 37
 79c:	83 60       	ori	r24, 0x03	; 3
 79e:	85 bd       	out	0x25, r24	; 37
		break;
 7a0:	08 95       	ret
		
		case clk_256 :
		TCCR2 |= (0 << 0) | (0 << 1) | (1 << 2);
 7a2:	85 b5       	in	r24, 0x25	; 37
 7a4:	84 60       	ori	r24, 0x04	; 4
 7a6:	85 bd       	out	0x25, r24	; 37
		break;
 7a8:	08 95       	ret
		
		case clk_1024 :
		TCCR2 |= (1 << 0) | (0 << 1) | (1 << 2);
 7aa:	85 b5       	in	r24, 0x25	; 37
 7ac:	85 60       	ori	r24, 0x05	; 5
 7ae:	85 bd       	out	0x25, r24	; 37
		break;
 7b0:	08 95       	ret
		
		case falling_edge :
		TCCR2 |= (0 << 0) | (1 << 1) | (1 << 2);
 7b2:	85 b5       	in	r24, 0x25	; 37
 7b4:	86 60       	ori	r24, 0x06	; 6
 7b6:	85 bd       	out	0x25, r24	; 37
		break;
 7b8:	08 95       	ret
		
		case rising_edge :
		TCCR2 |= (1 << 0) | (1 << 1) | (1 << 2);
 7ba:	85 b5       	in	r24, 0x25	; 37
 7bc:	87 60       	ori	r24, 0x07	; 7
 7be:	85 bd       	out	0x25, r24	; 37
 7c0:	08 95       	ret

000007c2 <Timer2_Stop>:
		
	}
}

void Timer2_Stop(void){       // stop timer2
	TCCR2 = 0;
 7c2:	15 bc       	out	0x25, r1	; 37
 7c4:	08 95       	ret

000007c6 <__subsf3>:
 7c6:	50 58       	subi	r21, 0x80	; 128

000007c8 <__addsf3>:
 7c8:	bb 27       	eor	r27, r27
 7ca:	aa 27       	eor	r26, r26
 7cc:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <__addsf3x>
 7d0:	0c 94 90 04 	jmp	0x920	; 0x920 <__fp_round>
 7d4:	0e 94 82 04 	call	0x904	; 0x904 <__fp_pscA>
 7d8:	38 f0       	brcs	.+14     	; 0x7e8 <__addsf3+0x20>
 7da:	0e 94 89 04 	call	0x912	; 0x912 <__fp_pscB>
 7de:	20 f0       	brcs	.+8      	; 0x7e8 <__addsf3+0x20>
 7e0:	39 f4       	brne	.+14     	; 0x7f0 <__addsf3+0x28>
 7e2:	9f 3f       	cpi	r25, 0xFF	; 255
 7e4:	19 f4       	brne	.+6      	; 0x7ec <__addsf3+0x24>
 7e6:	26 f4       	brtc	.+8      	; 0x7f0 <__addsf3+0x28>
 7e8:	0c 94 7f 04 	jmp	0x8fe	; 0x8fe <__fp_nan>
 7ec:	0e f4       	brtc	.+2      	; 0x7f0 <__addsf3+0x28>
 7ee:	e0 95       	com	r30
 7f0:	e7 fb       	bst	r30, 7
 7f2:	0c 94 79 04 	jmp	0x8f2	; 0x8f2 <__fp_inf>

000007f6 <__addsf3x>:
 7f6:	e9 2f       	mov	r30, r25
 7f8:	0e 94 a1 04 	call	0x942	; 0x942 <__fp_split3>
 7fc:	58 f3       	brcs	.-42     	; 0x7d4 <__addsf3+0xc>
 7fe:	ba 17       	cp	r27, r26
 800:	62 07       	cpc	r22, r18
 802:	73 07       	cpc	r23, r19
 804:	84 07       	cpc	r24, r20
 806:	95 07       	cpc	r25, r21
 808:	20 f0       	brcs	.+8      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
 80a:	79 f4       	brne	.+30     	; 0x82a <__DATA_REGION_LENGTH__+0x2a>
 80c:	a6 f5       	brtc	.+104    	; 0x876 <__stack+0x17>
 80e:	0c 94 c3 04 	jmp	0x986	; 0x986 <__fp_zero>
 812:	0e f4       	brtc	.+2      	; 0x816 <__DATA_REGION_LENGTH__+0x16>
 814:	e0 95       	com	r30
 816:	0b 2e       	mov	r0, r27
 818:	ba 2f       	mov	r27, r26
 81a:	a0 2d       	mov	r26, r0
 81c:	0b 01       	movw	r0, r22
 81e:	b9 01       	movw	r22, r18
 820:	90 01       	movw	r18, r0
 822:	0c 01       	movw	r0, r24
 824:	ca 01       	movw	r24, r20
 826:	a0 01       	movw	r20, r0
 828:	11 24       	eor	r1, r1
 82a:	ff 27       	eor	r31, r31
 82c:	59 1b       	sub	r21, r25
 82e:	99 f0       	breq	.+38     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
 830:	59 3f       	cpi	r21, 0xF9	; 249
 832:	50 f4       	brcc	.+20     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
 834:	50 3e       	cpi	r21, 0xE0	; 224
 836:	68 f1       	brcs	.+90     	; 0x892 <__stack+0x33>
 838:	1a 16       	cp	r1, r26
 83a:	f0 40       	sbci	r31, 0x00	; 0
 83c:	a2 2f       	mov	r26, r18
 83e:	23 2f       	mov	r18, r19
 840:	34 2f       	mov	r19, r20
 842:	44 27       	eor	r20, r20
 844:	58 5f       	subi	r21, 0xF8	; 248
 846:	f3 cf       	rjmp	.-26     	; 0x82e <__DATA_REGION_LENGTH__+0x2e>
 848:	46 95       	lsr	r20
 84a:	37 95       	ror	r19
 84c:	27 95       	ror	r18
 84e:	a7 95       	ror	r26
 850:	f0 40       	sbci	r31, 0x00	; 0
 852:	53 95       	inc	r21
 854:	c9 f7       	brne	.-14     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
 856:	7e f4       	brtc	.+30     	; 0x876 <__stack+0x17>
 858:	1f 16       	cp	r1, r31
 85a:	ba 0b       	sbc	r27, r26
 85c:	62 0b       	sbc	r22, r18
 85e:	73 0b       	sbc	r23, r19
 860:	84 0b       	sbc	r24, r20
 862:	ba f0       	brmi	.+46     	; 0x892 <__stack+0x33>
 864:	91 50       	subi	r25, 0x01	; 1
 866:	a1 f0       	breq	.+40     	; 0x890 <__stack+0x31>
 868:	ff 0f       	add	r31, r31
 86a:	bb 1f       	adc	r27, r27
 86c:	66 1f       	adc	r22, r22
 86e:	77 1f       	adc	r23, r23
 870:	88 1f       	adc	r24, r24
 872:	c2 f7       	brpl	.-16     	; 0x864 <__stack+0x5>
 874:	0e c0       	rjmp	.+28     	; 0x892 <__stack+0x33>
 876:	ba 0f       	add	r27, r26
 878:	62 1f       	adc	r22, r18
 87a:	73 1f       	adc	r23, r19
 87c:	84 1f       	adc	r24, r20
 87e:	48 f4       	brcc	.+18     	; 0x892 <__stack+0x33>
 880:	87 95       	ror	r24
 882:	77 95       	ror	r23
 884:	67 95       	ror	r22
 886:	b7 95       	ror	r27
 888:	f7 95       	ror	r31
 88a:	9e 3f       	cpi	r25, 0xFE	; 254
 88c:	08 f0       	brcs	.+2      	; 0x890 <__stack+0x31>
 88e:	b0 cf       	rjmp	.-160    	; 0x7f0 <__addsf3+0x28>
 890:	93 95       	inc	r25
 892:	88 0f       	add	r24, r24
 894:	08 f0       	brcs	.+2      	; 0x898 <__stack+0x39>
 896:	99 27       	eor	r25, r25
 898:	ee 0f       	add	r30, r30
 89a:	97 95       	ror	r25
 89c:	87 95       	ror	r24
 89e:	08 95       	ret

000008a0 <__cmpsf2>:
 8a0:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fp_cmp>
 8a4:	08 f4       	brcc	.+2      	; 0x8a8 <__cmpsf2+0x8>
 8a6:	81 e0       	ldi	r24, 0x01	; 1
 8a8:	08 95       	ret

000008aa <__fp_cmp>:
 8aa:	99 0f       	add	r25, r25
 8ac:	00 08       	sbc	r0, r0
 8ae:	55 0f       	add	r21, r21
 8b0:	aa 0b       	sbc	r26, r26
 8b2:	e0 e8       	ldi	r30, 0x80	; 128
 8b4:	fe ef       	ldi	r31, 0xFE	; 254
 8b6:	16 16       	cp	r1, r22
 8b8:	17 06       	cpc	r1, r23
 8ba:	e8 07       	cpc	r30, r24
 8bc:	f9 07       	cpc	r31, r25
 8be:	c0 f0       	brcs	.+48     	; 0x8f0 <__fp_cmp+0x46>
 8c0:	12 16       	cp	r1, r18
 8c2:	13 06       	cpc	r1, r19
 8c4:	e4 07       	cpc	r30, r20
 8c6:	f5 07       	cpc	r31, r21
 8c8:	98 f0       	brcs	.+38     	; 0x8f0 <__fp_cmp+0x46>
 8ca:	62 1b       	sub	r22, r18
 8cc:	73 0b       	sbc	r23, r19
 8ce:	84 0b       	sbc	r24, r20
 8d0:	95 0b       	sbc	r25, r21
 8d2:	39 f4       	brne	.+14     	; 0x8e2 <__fp_cmp+0x38>
 8d4:	0a 26       	eor	r0, r26
 8d6:	61 f0       	breq	.+24     	; 0x8f0 <__fp_cmp+0x46>
 8d8:	23 2b       	or	r18, r19
 8da:	24 2b       	or	r18, r20
 8dc:	25 2b       	or	r18, r21
 8de:	21 f4       	brne	.+8      	; 0x8e8 <__fp_cmp+0x3e>
 8e0:	08 95       	ret
 8e2:	0a 26       	eor	r0, r26
 8e4:	09 f4       	brne	.+2      	; 0x8e8 <__fp_cmp+0x3e>
 8e6:	a1 40       	sbci	r26, 0x01	; 1
 8e8:	a6 95       	lsr	r26
 8ea:	8f ef       	ldi	r24, 0xFF	; 255
 8ec:	81 1d       	adc	r24, r1
 8ee:	81 1d       	adc	r24, r1
 8f0:	08 95       	ret

000008f2 <__fp_inf>:
 8f2:	97 f9       	bld	r25, 7
 8f4:	9f 67       	ori	r25, 0x7F	; 127
 8f6:	80 e8       	ldi	r24, 0x80	; 128
 8f8:	70 e0       	ldi	r23, 0x00	; 0
 8fa:	60 e0       	ldi	r22, 0x00	; 0
 8fc:	08 95       	ret

000008fe <__fp_nan>:
 8fe:	9f ef       	ldi	r25, 0xFF	; 255
 900:	80 ec       	ldi	r24, 0xC0	; 192
 902:	08 95       	ret

00000904 <__fp_pscA>:
 904:	00 24       	eor	r0, r0
 906:	0a 94       	dec	r0
 908:	16 16       	cp	r1, r22
 90a:	17 06       	cpc	r1, r23
 90c:	18 06       	cpc	r1, r24
 90e:	09 06       	cpc	r0, r25
 910:	08 95       	ret

00000912 <__fp_pscB>:
 912:	00 24       	eor	r0, r0
 914:	0a 94       	dec	r0
 916:	12 16       	cp	r1, r18
 918:	13 06       	cpc	r1, r19
 91a:	14 06       	cpc	r1, r20
 91c:	05 06       	cpc	r0, r21
 91e:	08 95       	ret

00000920 <__fp_round>:
 920:	09 2e       	mov	r0, r25
 922:	03 94       	inc	r0
 924:	00 0c       	add	r0, r0
 926:	11 f4       	brne	.+4      	; 0x92c <__fp_round+0xc>
 928:	88 23       	and	r24, r24
 92a:	52 f0       	brmi	.+20     	; 0x940 <__fp_round+0x20>
 92c:	bb 0f       	add	r27, r27
 92e:	40 f4       	brcc	.+16     	; 0x940 <__fp_round+0x20>
 930:	bf 2b       	or	r27, r31
 932:	11 f4       	brne	.+4      	; 0x938 <__fp_round+0x18>
 934:	60 ff       	sbrs	r22, 0
 936:	04 c0       	rjmp	.+8      	; 0x940 <__fp_round+0x20>
 938:	6f 5f       	subi	r22, 0xFF	; 255
 93a:	7f 4f       	sbci	r23, 0xFF	; 255
 93c:	8f 4f       	sbci	r24, 0xFF	; 255
 93e:	9f 4f       	sbci	r25, 0xFF	; 255
 940:	08 95       	ret

00000942 <__fp_split3>:
 942:	57 fd       	sbrc	r21, 7
 944:	90 58       	subi	r25, 0x80	; 128
 946:	44 0f       	add	r20, r20
 948:	55 1f       	adc	r21, r21
 94a:	59 f0       	breq	.+22     	; 0x962 <__fp_splitA+0x10>
 94c:	5f 3f       	cpi	r21, 0xFF	; 255
 94e:	71 f0       	breq	.+28     	; 0x96c <__fp_splitA+0x1a>
 950:	47 95       	ror	r20

00000952 <__fp_splitA>:
 952:	88 0f       	add	r24, r24
 954:	97 fb       	bst	r25, 7
 956:	99 1f       	adc	r25, r25
 958:	61 f0       	breq	.+24     	; 0x972 <__fp_splitA+0x20>
 95a:	9f 3f       	cpi	r25, 0xFF	; 255
 95c:	79 f0       	breq	.+30     	; 0x97c <__fp_splitA+0x2a>
 95e:	87 95       	ror	r24
 960:	08 95       	ret
 962:	12 16       	cp	r1, r18
 964:	13 06       	cpc	r1, r19
 966:	14 06       	cpc	r1, r20
 968:	55 1f       	adc	r21, r21
 96a:	f2 cf       	rjmp	.-28     	; 0x950 <__fp_split3+0xe>
 96c:	46 95       	lsr	r20
 96e:	f1 df       	rcall	.-30     	; 0x952 <__fp_splitA>
 970:	08 c0       	rjmp	.+16     	; 0x982 <__fp_splitA+0x30>
 972:	16 16       	cp	r1, r22
 974:	17 06       	cpc	r1, r23
 976:	18 06       	cpc	r1, r24
 978:	99 1f       	adc	r25, r25
 97a:	f1 cf       	rjmp	.-30     	; 0x95e <__fp_splitA+0xc>
 97c:	86 95       	lsr	r24
 97e:	71 05       	cpc	r23, r1
 980:	61 05       	cpc	r22, r1
 982:	08 94       	sec
 984:	08 95       	ret

00000986 <__fp_zero>:
 986:	e8 94       	clt

00000988 <__fp_szero>:
 988:	bb 27       	eor	r27, r27
 98a:	66 27       	eor	r22, r22
 98c:	77 27       	eor	r23, r23
 98e:	cb 01       	movw	r24, r22
 990:	97 f9       	bld	r25, 7
 992:	08 95       	ret

00000994 <__tablejump2__>:
 994:	ee 0f       	add	r30, r30
 996:	ff 1f       	adc	r31, r31
 998:	05 90       	lpm	r0, Z+
 99a:	f4 91       	lpm	r31, Z
 99c:	e0 2d       	mov	r30, r0
 99e:	09 94       	ijmp

000009a0 <_exit>:
 9a0:	f8 94       	cli

000009a2 <__stop_program>:
 9a2:	ff cf       	rjmp	.-2      	; 0x9a2 <__stop_program>
